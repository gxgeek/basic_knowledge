##Tcp 三次握手

一条客户端 到 服务端的请求连接  
一条服务端 到 客户端的确认消息  
一条客户端 到 服务端的确认消息  

TCP 的开放握手也称为 3 次握手（3-way handshake），因为这通常包括 3 条消息：一
条从客户端到服务器端的连接请求，一条从服务器端到客户端的确认消息，以及另一条从客
户端到服务器端的确认消息。客户端一收到服务器端发来的确认消息，就立即认为连接已经
成功建立。通常情况这个过程发生得很快。然而，互联网是一种尽力而为（best-effort）的
网络，客户端的起始消息或服务器端的回复消息都可能在传输过程中丢失。出于这个原因，
TCP 协议实现将以递增的时间间隔重复发送几次握手消息。如果 TCP 客户端在一段时间后
还没有收到服务器的回复消息，则发生超时并放弃连接。这种情况下，构造函数将抛出
IOException 异常。连接的超时通常比较长，因此要经过几分种的时间 Socket 的构造函数才
会失败。

其中，"SYN_SENT"是在第一条和第二条握手消息之间，客户端状态的专业名称。  

在客户端收到了服务器端的肯定回复后 ESTABLISHED


服务器首先创
建一个 ServerSocket 实例，并将其与已知端口相关联（在此为 Q）。套接字实现为新的
ServerSocket 实例创建了一个底层数据结构，并将 Q 赋给本地端口，将特定的通配符地址（图
中的"*"）赋给本地 IP 地址。（服务器也可能会在构造函数中指定一个本地 IP 地址，但是
通常不这样做。对于服务器主机有多个 IP 地址的情况，不指定本地地址使套接能够接受发
送到该服务器主机任何地址的连接请求。）套接字的状态设置为"LISTENING"

当客户端的连接请求到来时，将为该连接创建一个新的套接字数据结构。新套接字的地
址根据到来的分组报文设置：分组报文的目标互联网地址和端口号（分别为 W.X.Y.Z 和 Q）
成为该套接字的本地互联网地址和端口号；而分组报文的源地址和端口号（分别为 A.B.C.D
和 P）则成为该套接字的远程互联网地址和端口号。注意，新套接字的本地端口号总是与
ServerSocket 的端口号一致。新套接字的状态设置为指示"正在连接（Connecting）"（在服务
器方，专业术语称其为 SYN_RCVD），并将其添加到 ServerSocket 套接字数据结构所关联
的一个未完全连接的套接字列表中。注意，ServerSocket 自己并不改变状态，其地址信息也
不会有任何改变。
此时，netstat 的输出内容应该包括原始的侦听套接字和新创建的套接字：  
Active Internet connections  
Proto Recv-Q Send-Q Local Address Foreign   Address State  
tcp 0 0 0.0.0.0:Q 0.0.0.0:0 LISTENING  
tcp 0 0 W.X.Y.Z:Q A.B.C.D:P SYN_RCVD

除了要创建一个新的底层套接字数据结构外，服务器方的 TCP 实现还要向客户端发回
一个 TCP 握手确认消息。

然而，在接收到客户端发来的 3 次握手的第 3 条消息之前，服务器端 TCP 并不会认为
握手消息已经完成。第 3 条握手消息到来后，新数据结构的状态则设置为"ESTABLISHED"，
并将其移动到 ServerSocket 数据结构关联的另一个套接字数据结构列表中，该列表代表了能
够通过 ServerSocket 的 accept()方法进行接收的已成功建立连接。（如果第 3 条握手消息接
收失败，最终会将"Connecting"状态的数据结构删除。）此时 netstat 的输出将包含：  
Active Internet connections  
Proto Recv-Q Send-Q Local Address Foreign   Address State  
tcp 0 0 0.0.0.0:Q 0.0.0.0:0 LISTENING  
tcp 0 0 W.X.Y.Z:Q A.B.C.D:P ESTABLISHED

现在，我们来考虑服务器程序调用了 ServerSocket 的 accept()方法后发生的事情。
只要其关联的套接字数据结构列表中有新的连接到来，该方法调用就立即停止阻塞。（注意，
在调用 accept()方法时，这个列表可能已经是非空状态。）此时，一个新的连接数据结构将
从列表中移除，并为其创建一个 Socket 实例，作为 accept()方法的返回值。
有非常重要的一点需要注意，在 ServerSocket 关联的列表中的每个数据结构，都代表了
一个与另一端的客户端已经完成建立的 TCP 连接。实际上，客户端只要接收到了开放握手
的第 2 条消息，就可以立即发送数据--这可能比服务器调用 accept()方法为其获取一个 Socket
实例要早很长时间。

##关闭TCP连接

TCP 协议有一个优雅的关闭（graceful close）机制，以保证应用程序在关闭连接时不必
担心正在传输的数据会丢失。如第 4.5 节的压缩示例程序所示，这个机制还设计为允许两个
方向的数据传输相互独立地终止。关闭机制的工作流程是：应用程序通过调用连接套接字的
close()方法或 shutdownOutput()方法表明数据已经发送完毕。此刻，底层的 TCP 实现首先将
留存在 SendQ 队列中的数据传输出去（还要依赖于另一端 RecvQ 队列的剩余空间），然后
向另一端发送一个关闭 TCP 连接的握手消息。该关闭握手消息可以看作是流终止标志：它
告诉接收端 TCP 不会再有新的数据传入 RecvQ 队列了。（注意，关闭握手消息本身并没有
传递给接收端应用程序，而是通过 read()方法返回-1 来指示其在字节流中的位置。）正在关
闭的 TCP 将等待其关闭握手消息的确认信息，该确认信息表明在连接上传输的所有数据已
经安全地传输到了 RecvQ 中。只要收到了确认消息，该连接就变成"半关闭（Half closed）"
状态。直到连接的另一个方向上收到了对称的握手消息后，连接才完全关闭--也就是说，连
接的两端都表明它们再没有数据要发送了。

  
TCP 连接的关闭事件序列可能以两种方式发生：一种方式是先由一个应用程序调用
close()方法（或 shutdownOutput()方法），并在另一端调用 close()方法之前完成其关闭握手
消息；另一种方式是两端同时调用 close()方法，它们的关闭握手消息在网络上交叉传输。图
6.10 展示了以第一种方式关闭连接时，底层实现中的事件序列。关闭握手消息已经发送，套
接字数据结构的状态也已经设置为"Closing"（专业术语称为"FIN_WAIT_1"），然后 close()
调用返回。完成这些工作后，将禁止在该 Socket 上的任何读写操作（会抛出异常）。当收
到关闭握手确认消息后，套接字数据结构的状态则改变为"半关闭"（专业术语称为
"FIN_WAIT_2"），这种状态将一直持续，直到接收到另一端的关闭握手消息。此时，客户
端 netstat 的输出内容将展示连接的状态为：  
Active Internet connections  
Proto Recv-Q Send-Q Local Address Foreign Address State  
tcp 0 0 A.B.C.D:P W.X.Y.Z:Q FIN_WAIT_2  
（在首先发起关闭的主机上，FIN_WAIT_2 是"半关闭"状态的专业术语。图中由
"Closing"指示的状态的专业术语是 FIN_WAIT_1，不过该状态非常转瞬即逝，很难被 netstat
捕获到。）

注意，如果连接处于半关闭状态时，远程终端已经离开，那么本地底层数据结构则将无
限期地保持在该状态。当另一端的关闭握手消息到达后，则发回一条确认消息并将状态改变

在图 6.10 的右端时，netstat 的输出内容包括：  
Active Internet connections  
Proto Recv-Q Send-Q Local Address Foreign Address State  
tcp 0 0 A.B.C.D:P W.X.Y.Z:Q TIME_WAIT  

（被动关闭）  
简单展示了没有首先发起关闭的终端上的事件序列。关闭握手消息到达后，它立即
发回一个确认消息，并将连接状态改变为"Close-Wait"。该主机上 netstat 的输出内容显示：
Active Internet connections
Proto Recv-Q Send-Q Local Address Foreign Address State
tcp 0 0 W.X.Y.Z:Q A.B.C.D:P CLOSE_WAIT
此时，只需要等待应用程序调用 Socket 的 close()方法。调用该方法后，将发起最终的
关闭握手消息，并释放底层套接字数据结构，虽然对原始 Socket 实例的引用仍然留存在 Java
程序中。    
此时，只需要等待应用程序调用 Socket 的 close()方法。调用该方法后，将发起最终的
关闭握手消息，并释放底层套接字数据结构，虽然对原始 Socket 实例的引用仍然留存在 Java
程序中。  
注意这样一个事实：close()方法和 shutdownOutput()方法都没有等待关闭握手的完成，
而是调用后立即返回。你可能会问，发送者怎样能保证已发送的数据能够真正到底接收程序
呢（即 Delivered）？实际上，当应用程序调用 close()或 shutdownOutput()方法并成功关闭连
接时，的确可能还有数据留存在 SendQ 队列中。如果连接的任何一端在数据传输到 RecvQ
队列之前崩溃，数据将丢失，而发送端应用程序却不会知道。  
最好的解决方案是设计一种应用程序协议，以使首先调用 close()方法的一方在接收到了应用
程序层的数据已接收保证后，才真正执行关闭操作。例如，当我们的 TCPEchoClient 程序接
收到了它所发送的数据的完全拷贝后，它就能够知道此时在连接两个方向上都没有数据在传
输，因此可以安全地关闭连接。   
Java 的确提供了一种能够修改 Socket 的 close()的行为的方法，即 setSoLinger()方法。
setSoLinger()用于控制 close()方法在返回前是否等待关闭握手的完成。它有两个参数：一个
布尔变量用来指示是否等待；一个整型变量用来指定放弃之前等待的时间（单位为秒）。也
就是说，使用 setSoLinger()设置了超时时间后，close()方法将阻塞等待，直到关闭握手完成
或指定时间超时。然而，在本书的写作期间，即使在 setSoLinger()设置的时间限制已经超过
时，close()方法也没有提供任何信息来指示关闭握手的失败。换句话说，setSoLinger()方法
没有为当前实现的应用程序提供任何额外担保。  
关闭 TCP 连接的最后微妙之处在于对 Time-Wait 状态的需要。TCP 规范要求在终止连
接时，两端的关闭握手都完成后，至少要有一个套接字在 Time-Wait 状态保持一段时间。这
个要求的提出是由于消息在网络中传输时可能延迟。如果在连接两端都完成了关闭握手后，
它们都移除了其底层数据结构，而此时在同样一对套接字地址之间又立即建立了新的连接，  
那么前一个连接在网络上传输时延迟的消息就可能在新连接建立后到达。由于其包含了相同
的源地址和目的地址，旧消息就会被错误地认为是属于新连接的，其包含的数据就可能被错
误地分配到应用程序中。
虽然这种情形可能很少发生，TCP 还是使用了包括 Time-Wait 状态在内的多种机制对其
进行防范。Time-Wait 状态用于保证每个 TCP 连接都在一段平静时间内结束，这期间不会有
数据发送。平静时间的长度应该等于分组报文在网络上存留的最长时间的两倍。因此，当一
个连接完全结束（即套接字数据结构离开 Time-Wait 状态并被删除），并为同样一对地址上
的新连接清理道路后，就不会再有旧实例发送的消息还存留在网络中。实际上，平静时间的
长度要依赖于具体实现，因为没有机制能真正限制分组报文在网络上能够延迟的时间。通常
使用的时间范围是 4 分钟减到 30 秒，或更短。  
Time-Wait 状态最重要的作用是，只要底层套接字数据结构还存在，就不允许在相同的
本地端口上关联其他套接字。尤其是试图使用该端口创建新的 Socket 实例时，将抛出
IOException 异常。

  解调多路复用揭秘  
在前面的讨论中已经隐含表明一个事实，即同一个机器上的不同套接字可以有相同的本
地地址和端口号。例如，在只有一个 IP 地址的机器上，每个通过 ServerSocket 的 accept()方
法接收的新 Socket 实例都将使用与 ServerSocket 相同的本地端口号。显然，要确定传入的
分组报文应该分配到那个套接字（即，解调多路复用）不仅仅是查看分组报文的目的地址和
端口。  
否则传入的分组报文应该分配给哪个套接字就会含糊不清。对于 TCP 和 UDP 来说，将
传入的分组报文匹配到某个套接字的过程是一样的，可以归纳为以下几点：  

套接字数据结构中的本地端口号必须与传入的分组报文的目的端口号相匹配。
在套接字数据结构中，任何包含了通配符（\*）的字段可以匹配分组报文中相应字段的
任何值。  
如果有一个以上的套接字数据结构与传入的分组报文地址的四个字段匹配，那么谁使用
的通配符少，谁就获得该分组报文。  
例如，考虑一个主机有两个 IP 地址的情况，10.1.2.3 和 192.168.3.2，还有如图 6.12 所
示的活跃的 TCP 套接字数据结构子集。标记为 0 的数据结构与一个 ServerSocket 关联，有
一个通配符本地地址，端口号为 99。标记为 1 的套接字数据结构也关联了同一个端口号的
ServerSocket，但其本地地址指定为 10.1.2.3（因此它只接收发向这个地址的连接请求）。数
据结构 2 代表了通过 ServerSocket 为数据结构 0 接收的一个连接，因此有相同的本地端口号，
但也填入了本地和远程互联网地址。其他套接字则属于其他活跃的连接。现在考虑一个分组
报文，其源 IP 地址是 172.16.1.10，源端口号是 56789，目的 IP 地址是 10.1.2.3，目的端口号
是 99。该报文将分配到与数据结构 1 相关联的套接字上，因为该套接字匹配的通配符最少。
当程序试图使用特定的本地端口号创建套接字时，要检查已有的套接字以确保没有其他
套接字已经使用了那个本地端口。如果已经有套接字与构造函数中指定的本地端口和本地
IP 地址（如果有的话）相匹配，Socket 的构造函数将抛出一个异常。这在如下情形中将导
致一些问题：  
1.客户端程序用特定的本地端口号 P 创建了一个 Socket 实例，并通过它与服务器进行通
信。  
2.客户端关闭了 Socket，底层数据结构进入了 Time-Wait 状态。  
3.客户端程序终止后又立即重新启动。  
如果新的客户端化身试图使用同样的本地端口号，而由于其他数据结构正处于
Time-Wait 状态，Socket 构造函数将抛出 IOException 异常。在写本书期间，解决这个问题
的唯一途径是等待底层数据结构离开 Time-Wait 状态。  
那么怎么确定本地或远程的地址和端口号呢？对于 ServerSocket，所有构造函数都要求
传入本地端口号。本地地址可能会在构造函数中指定，否则，就使用通配符（*）地址。  
  
ServerSocket 的远程地址和端口号始终是通配符。对于 Socket，所有构造函数都要求传入特
定的远程地址和端口号。本地地址或端口号可能会在构造函数中指定，否则，本地地址就使
用用来建立到服务器的连接的网络接口地址，本地端口号就随机选择一个大于 1023 的未使
用端口号。对于 accept()方法返回的 Socket 实例，本地地址是从客户端发起的初始握手消息
的目的地址，本地端口号是 SeverSocket 的本地端口，远程地址和端口号则是客户端的本地
地址和端口号。  
   对于 DatagramSocket，本地地址和端口可能会在构造函数中指定，否则，本
地地址将使用通配符地址，本地端口则随机选择一个大于 1023 的未使用端口号，远程地址
和端口号都初始化为通配符并一直保持下去，除非调用 connect()方法指定了特定的值。